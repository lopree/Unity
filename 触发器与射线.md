 # 触发器(Trigger)
## 一,条件

---

> 触发检测的条件
1. 两个物体身上都要有碰撞器(Collision),并且其中一个要成为触发器(另行创建一个碰撞器,将至变为触发器)
2. 两个物体至少要有一个带有刚体,一般给运动的物体添加刚体


==注意: 当游戏对象身上的碰撞器变为触发器,会有穿透效果,可以通过另外添加一个碰撞器在触发器上解决.==

## 二,语法
```cs
//进入触发器时条用
void OnTriggerEnter(Collider other){}

//处于触发器范围内时条用
void OnTriggerStay(Collider other){}

//离开触发器时条用
void OnTriggerExit(Collider other){}
```
## 三,查找游戏中物体的方法
```cs
void Start(){
//1.如果游戏场景中有重名的情况,我们使用GameObject可以指定路径查找
Debug.Log(GameObject.Find("Cube").tag);
//通过路径查找Cube的父物体Cube1
Debug.Log (GameObject.Find("Cube /Cube1").tag);
}

//2.transform只能查找子物体,如果想查找子物体的子物体需要使用符号'/'表示层级关系
//注意:必须保证脚本所在的游戏物体必须是激活状态
Debug.Log(transform.Find("Cube1").tag);
Debug.Log(transform.Find("Cube1/Cube").tag);

//3.GameObject可以查找所有未被隐藏的游戏物体,而transform只能查找子物体(不管是否隐藏都可以找到)

//4. 注意:尽量不要在Update中查找对象,可以采取在Start或者Awake方法中查找,然后存储到一个变量中,方便之后使用

```

---

---

# 射线(Ray)
## 摄像机发射射线
```cs
    //子弹预设
	public GameObject bulletPre;
	//接受射线碰撞信息的参数
	RaycastHit hitInfo;
void Update ()
	{
		//从摄像机向场景中发射射线
		if (Input.GetMouseButtonDown (0)) {
			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
			if (Physics.Raycast (ray, out hitInfo)) {
				Debug.DrawLine (transform.position, hitInfo.point, Color.red);
				//子弹的方向
				Vector3 dir = hitInfo.point - transform.position;
				//获取子弹身上的刚体,添加力
				GameObject bullet = Instantiate (bulletPre, transform.position, Quaternion.identity);
				bullet.GetComponent <Rigidbody > ().AddForce (dir.normalized * 1000f);
				GameObject.Destroy (bullet, 3f);
			}
		}
	}
```

## 寻路(走到鼠标点击的位置)
```cs
    float ver, hor;
	//射线碰撞到的游戏物体信息
	RaycastHit hinInfo;
	//目标点
	Vector3 targetPos;
	//是否移动,默认false
	bool isMove = false;
	//旋转四元数
	Quaternion qua;
void Updat (){
    ver = Input.GetAxis ("Vertical");
		hor = Input.GetAxis ("Horizontal");
		transform.Translate (new Vector3 (0, 0, ver) * Time.deltaTime * 10f);
		transform.Rotate (new Vector3 (0, hor, 0) * Time.deltaTime * 30f);

		//创建射线,发射点及方向
		Ray ray = new Ray (transform.position, transform.forward);
		//发射射线
		bool result = Physics.Raycast (ray, out hinInfo, 10f);
		if (result) {
			Debug.Log (hinInfo.collider.gameObject.name);


		}
		//hinInfo .point :射线碰撞到的点
		Debug.DrawLine (Camera.main.transform.position, hinInfo.point, Color.red);
		//实现鼠标点哪移动到哪儿
		if (Input.GetMouseButtonDown (0)) {
			Ray cameraRay = Camera.main.ScreenPointToRay (Input.mousePosition);
			if (Physics.Raycast (cameraRay, out hinInfo)) {
				Vector3 temp = new Vector3 (hinInfo.point.x, 0.5f, hinInfo.point.z);
				targetPos = temp;

				//要旋转的四元数
				qua = Quaternion.LookRotation (targetPos - transform.position);

				isMove = true;

			}
		}
		if (isMove) {
			//先旋转后移动
//			transform.rotation = Quaternion.Lerp (transform.rotation, qua, Time.deltaTime * 20);
//			if (Quaternion.Angle (transform.rotation, qua) <= 0.5f) {
//				transform.position = Vector3.Lerp (transform.position, targetPos, Time.deltaTime * 10);
//			}
			//一边旋转一边移动
			transform.rotation = Quaternion.Lerp (transform.rotation, qua, Time.deltaTime);
			transform.position = Vector3.Lerp (transform.position, targetPos, Time.deltaTime);


		}
		//如果到目标点的距离小于0.3就代表到达目标点
		if (Vector3.Distance (transform.position, targetPos) < 0.3f) {
			isMove = false;
		}
}

```
